import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, models

# ==========================================
# 1. SYNTHETIC DATA GENERATION
# ==========================================
def generate_synthetic_drought_data(n_samples=500, n_timesteps=12, grid_size=(16, 16)):
    """
    Creates a synthetic dataset of SPI (Standardized Precipitation Index) values.
    Simulates spatiotemporal correlation by rolling data over time.
    """
    # Create random noise base
    data = np.random.uniform(0, 1, (n_samples, n_timesteps, *grid_size, 1))
    
    # Apply spatial shifts to simulate drought movement/evolution
    for i in range(n_samples):
        shift_x = np.random.randint(0, 2)
        shift_y = np.random.randint(0, 2)
        for t in range(1, n_timesteps):
            # The next state is 70% current state + 30% shifted state + minor noise
            prev_frame = data[i, t-1]
            shifted_frame = np.roll(prev_frame, (shift_x, shift_y), axis=(0, 1))
            data[i, t] = 0.7 * prev_frame + 0.3 * shifted_frame + np.random.normal(0, 0.01, grid_size + (1,))
            
    # Normalize to [0, 1] range
    data = np.clip(data, 0, 1)
    return data

# Parameters
N_SAMPLES = 800
TIMESTEPS = 10
GRID_SIZE = (16, 16)

# Generate and split into X (input sequence) and y (target frame)
full_data = generate_synthetic_drought_data(N_SAMPLES, TIMESTEPS, GRID_SIZE)
X = full_data[:, :-1, ...]  # First 9 months
y = full_data[:, -1, ...]   # 10th month (to predict)

# ==========================================
# 2. CONVLSTM MODEL ARCHITECTURE
# ==========================================


def build_spatiotemporal_model(input_shape):
    model = models.Sequential([
        # Input layer expects (Time, Row, Col, Channels)
        layers.Input(shape=input_shape),
        
        # ConvLSTM layer captures spatial patterns over time
        layers.ConvLSTM2D(filters=64, kernel_size=(3, 3), padding='same', 
                          return_sequences=True, activation='relu'),
        layers.BatchNormalization(),
        
        # Second ConvLSTM layer reduces temporal dimension
        layers.ConvLSTM2D(filters=32, kernel_size=(3, 3), padding='same', 
                          return_sequences=False, activation='relu'),
        layers.BatchNormalization(),
        
        # Conv2D layer collapses the filters into a single prediction map
        layers.Conv2D(filters=1, kernel_size=(3, 3), activation='sigmoid', padding='same')
    ])
    
    model.compile(optimizer='adam', loss='mse', metrics=['mae'])
    return model

# Initialize model
input_dims = (TIMESTEPS - 1, GRID_SIZE[0], GRID_SIZE[1], 1)
model = build_spatiotemporal_model(input_dims)
model.summary()

# ==========================================
# 3. TRAINING
# ==========================================
print("\nStarting training...")
history = model.fit(X, y, batch_size=32, epochs=15, validation_split=0.2, verbose=1)

# ==========================================
# 4. VISUALIZATION OF RESULTS
# ==========================================
# Pick a random sample from the test set
sample_idx = np.random.randint(0, 100)
test_input = X[sample_idx:sample_idx+1]
ground_truth = y[sample_idx]
prediction = model.predict(test_input)[0]

fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# Plot the last observed month in the sequence
im0 = axes[0].imshow(test_input[0, -1, :, :, 0], cmap='RdYlBu')
axes[0].set_title(f"Observation (Month {TIMESTEPS-1})")
plt.colorbar(im0, ax=axes[0])

# Plot the actual "future" month
im1 = axes[1].imshow(ground_truth[:, :, 0], cmap='RdYlBu')
axes[1].set_title(f"Ground Truth (Month {TIMESTEPS})")
plt.colorbar(im1, ax=axes[1])

# Plot the model's forecast
im2 = axes[2].imshow(prediction[:, :, 0], cmap='RdYlBu')
axes[2].set_title(f"Model Forecast (Month {TIMESTEPS})")
plt.colorbar(im2, ax=axes[2])

plt.tight_layout()
plt.show()
